#!/usr/bin/env bash

[[ -f ~/.mdsctl ]] && . ~/.mdsctl
osx=darwin
linux=linux

exists() {
  hash ${1} > /dev/null 2>&1
  echo $?
}

lower() {
  echo "${1}" | tr '[:upper:]' '[:lower:]'
}

os() {
  os=${MDS_OS:-$(uname)}
  case "$(lower ${os})" in
    ${osx} | ${linux}) echo $(lower ${os});;
    *) echo "unsupported";;
  esac; unset os
}

[[ "$(exists brew)" != "0" ]] && {
  case "$(os)" in
    ${osx})
      /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)";;
    ${linux})
      mkdir -p ~/.linuxbrew/bin
      [[ "$(exists git)" != "0" ]] && (apt-get update; apt-get install -y git)
      git clone https://github.com/Homebrew/brew ~/.linuxbrew/Homebrew
      ln -s ~/.linuxbrew/Homebrew/bin/brew ~/.linuxbrew/bin
      [ $(grep -Fxq "eval \$(~/.linuxbrew/bin/brew shellenv)" ~/.bashrc; echo $?) == "1" ] && \
        echo "eval \$(~/.linuxbrew/bin/brew shellenv)" >> ~/.bashrc
      [[ "$(exists curl)" != "0" ]] && (apt-get update; apt-get install -y curl)
      eval $(~/.linuxbrew/bin/brew shellenv);;
    *) usage "unsupported os: $(uname)";;
  esac
}

if [[ "$(bash -c 'echo $BASH_VERSION')" == 3* ]]; then
  case "$(os)" in
    ${osx} | ${linux})
      brew install bash
      $(brew --prefix bash)/bin/bash -c "${0} ${@}";;
    *) usage "unsupported os: $(uname)";;
  esac
fi

installDir() {
  source="${BASH_SOURCE[0]}";

  while [ -h "${source}" ]; do
    dir="$(cd -P "$(dirname "${source}")" && pwd)"
    source="$(readlink "${source}")"

    [[ ${source} != /* ]] && source="${dir}/${source}"
  done

  id="$(cd -P "$(dirname "${source}")" && pwd)"

  echo $(dirname "${id}")
}

declare -A os=(
  ["osx"]="${osx}"
  ["linux"]="${linux}")
declare -A configs=(
  ["profiles"]="${MDS_PROFILE:-}"
  ["local-context"]="${MDS_LOCACL_CONTEXT:-docker-desktop|docker-for-desktop|minikube}"
  ["home"]="${MDS_HOME:-$(installDir)}"
  ["os"]="${MDS_OS:-`uname`}"
  ["provider"]="${MDS_PROVIDER:-}"
  ["nvm-version"]="${MDS_NVM_VERSION:-14.2.0}"
  ["workdir"]="/tmp/mds/tools"
  # fixme: consider removing envsubst in favor of sed
  ["brew"]="${MDS_BREW:-oq jq envsubst yarn nvm helm k9s kubectx git aws nsc sops}"
  ["brew-envsubst"]="gettext"
  ["brew-helm"]="helm@2"
  ["brew-k9s"]="derailed/k9s/k9s"
  ["brew-aws"]="awscli"
  ["brew-oq"]="blacksmoke16/tap"
  ["brew-nsc"]="nats-io/nats-tools"
  ["brew-cask"]="${MDS_BREW_CASK:-gcloud}"
  ["brew-cask-gcloud"]="google-cloud-sdk"
  ["helm-version"]="${MDS_HELM_VERSION:-2.14.1}"
  ["helm-distribution"]="${MDS_HELM_DISTRIBUTION:-https://get.helm.sh/helm-v${configs[helm-version]}-{os\}-amd64.tar.gz}"
  ["helm-secrets"]="${MDS_HELM_SECRETS:-}"
  ["helm-upgrade-release"]="${MDS_HELM_UPGRADE_RELEASE:-}"
  ["helm-cluster"]="${MDS_HELM_CLUSTER:-}"
  ["helm-environment"]="${MDS_HELM_ENVIRONMENT:-}"
  ["helm-mds"]="${MDS_HELM_MDS=:-}"
  ["interactive"]="${MDS_INTERACTIVE:-}"
  ["paths"]="${MDS_PATHS:-envsubst helm}"
  ["tools"]="${MDS_TOOLCHAIN:-helm,pgcli}"
  ["image-repository"]="${MDS_IMAGE_REPOSITORY:-}"
  ["simulator-repository"]="${MDS_SIMULATOR_REPOSITORY:-}"
  ["operations-repository"]="${MDS_OPERATIONS_REPOSITORY:-}"
  ["credentials-repository"]="${MDS_CREDENTIALS_REPOSITORY:-}"
  ["bootstrap"]="${MDS_BOOTSTRAP:-helm,istio,nats}"
  ["install"]="${MDS_INSTALL:-mds}"
  ["test"]="${MDS_TEST:-unit,integration}"
  ["uninstall"]="${MDS_UNINSTALL:-logging,mds,nats,operations,simulator,istio,helm}"
  ["forward"]="${MDS_FORWARD:-default}"
  ["reinstall"]="${MDS_REINSTALL:-mds}"
  ["pause"]="${MDS_PAUSE:-3}"
  ["pause-kubectl"]="${MDS_PAUSE_KUBECTL:-45}"
  # note: istio-version=1.4.2 (latest) has been verified for development environments
  ["istio-version"]="${MDS_ISTIO_VERSION:-1.3.6}"
  # note: fails when installing istio-nodeagent (i.e. -istio-sds-auth)
  ["istio-profile"]="${MDS_ISTIO_PROFILE:-}"
  ["istio"]="${MDS_ISTIO_PATH:-${configs[workdir]}/istio-${configs[istio-version]}}"
  ["nats"]="${MDS_NATS_PATH:-${configs[workdir]}/nats}"
  ["grafana-plugins"]="${MDS_GRAFANA_PLUGINS:-devopsprodigy-kubegraf-app}"
  ["simulator"]="${MDS_SIMULATOR:-${configs[workdir]}/simulator}"
  ["operations"]="${MDS_OPERATIONS:-${configs[workdir]}/operations}"
  ["credentials"]="${MDS_CREDENTIALS:-${configs[workdir]}/credentials}"
  ["ingress-domain"]="${MDS_INGRESS_DOMAIN:-}"
  ["ingress-gateway-key-path"]="${MDS_INGRESS_GATEWAY_KEY_PATH:-}"
  ["ingress-gateway-certificate-path"]="${MDS_INGRESS_GATEWAY_CERTIFICATE_PATH:-}"
  ["values"]="${MDS_VALUES:-}"
  ["values-mds"]="${MDS_VALUES_MDS:-}"
  ["values-nats"]="${MDS_VALUES_NATS:-}"
  ["presets"]="${MDS_PRESETS:-}"
  ["presets-mds-database-password"]="${MDS_PRESETS_MDS_DATABASE_PASSWORD:-Password123#}"
  ["presets-mds"]="${MDS_PRESETS_MDS:-postgresql.password=${configs[presets-mds-database-password]},apis.mds-agency.migration=true}"
  ["presets-nats"]="${MDS_PRESETS_NATS:-cluster.enabled=true}" #,natsbox.enabled=false}"
  ["sets"]="${MDS_SETS:-}"
  ["sets-mds"]="${MDS_SETS_MDS:-}"
  ["sets-nats"]="${MDS_SETS_NATS:-}"
  # todo: try scaling down istio's resource requirements (e.g. local dev): pilot.resources.requests.memory=512Mi}
  ["sets-istio"]="${MDS_SETS_ISTIO:-}"
  ["sets-logging"]="${MDS_SETS_LOGGING:-fluentbit.backend.es.host=elasticsearch-master.util,fluentbit.backend.es.port=9200,fluentbit.backend.es.tls=off,kibana.env.ELASTICSEARCH_URL=http:elasticsearch-master.util:9200}"
  ["sets-simulator"]="${MDS_SETS_SIMULATOR:-jwt.enabled=false,registry=}"
  ["setfiles"]="${MDS_SET_FILES:-}"
  ["setfiles-mds"]="${MDS_SET_FILES_MDS:-}"
  ["namespace"]="${MDS_NAMESPACE:-default}"
  ["namespace-metrics-adapter"]="${MDS_NAMESPACE_METRICS_ADAPTER:-util}"
  ["namespace-dashboard"]="${MDS_NAMESPACE_LOGGING:-dashboard}"
  ["namespace-logging"]="${MDS_NAMESPACE_LOGGING:-util}"
  ["namespace-mds"]="${MDS_NAMESPACE_MDS:-mds}"
  ["namespace-simulator"]="${MDS_NAMESPACE_SIMULATOR:-${configs[namespace-mds]}}"
  ["namespace-nats"]="${MDS_NAMESPACE_NATS:-nats}"
  ["namespace-nats-init"]="${MDS_NAMESPACE_NATS_INIT:-nats-admin}"
  ["namespace-nats-account-server"]="${MDS_NAMESPACE_NATS_ACCOUNT_SERVER:-${configs[namespace-nats]}}"
  ["namespace-nats-box"]="${MDS_NAMESPACE_NATS_BOX:-${configs[namespace-nats]}}"
  ["namespace-dns"]="${MDS_NAMESPACE_DNS:-default}"
  ["namespace-curl"]="${MDS_NAMESPACE_CURL:-default}"
  ["dryrun"]="${MDS_DRY_RUN:-}"
  ["quiet"]="${MDS_QUIET:-}"
  ["keep-cache"]="${MDS_KEEP_CACHE:-}")
declare -A helmRepositories=(
  ["stable"]="https://kubernetes-charts.storage.googleapis.com"
  ["istio.io"]="https://storage.googleapis.com/istio-release/releases/${configs[istio-version]}/charts"
  ["banzaicloud-stable"]="https://kubernetes-charts.banzaicloud.com"
  ["elastic"]="https://helm.elastic.co"
  ["bitnami"]="https://charts.bitnami.com/bitnami"
  ["nats"]=" https://nats-io.github.io/k8s/helm/charts")
declare -A helmPlugins=(
  ["unittest"]=https://github.com/lrills/helm-unittest
  ["secrets"]=https://github.com/futuresimple/helm-secrets
  ["diff"]="https://github.com/databus23/helm-diff --version master"
  ["monitor"]="https://github.com/ContainerSolutions/helm-monitor"
  ["edit"]="https://github.com/mstrzele/helm-edit"
  ["last"]="https://github.com/adamreese/helm-last"
  ["env"]="https://github.com/adamreese/helm-env"
)
declare -A apps=(
  ["mds-agency"]="https://localhost:[port]/agency,mds,app"
  ["mds-audit"]="https://localhost:[port]/audit,mds,app"
  ["mds-compliance"]="https://localhost:[port]/compliance,mds,app"
  ["mds-daily"]="https://localhost:[port]/daily,mds,app"
  ["mds-geography"]="https://localhost:[port]/geography,mds,app"
  ["mds-geography-author"]="https://localhost:[port]/geography-author,mds,app"
  ["mds-jurisdiction"]="https://localhost:[port]/jurisdiction,mds,app"
  ["mds-jurisdiction-service"]="https://localhost:[port]/jurisdiction-service,mds,app"
  ["mds-policy"]="https://localhost:[port]/policy,mds,app"
  ["mds-policy-author"]="https://localhost:[port]/policy-author,mds,app"
  ["mds-postgresql"]="https://localhost:[port]/postgresql,mds,app,postgresql"
  ["mds-redis"]="https://localhost:[port]/redis,mds,app,redis"
  ["grafana"]="http://localhost:[port]/dashboard/db/istio-mesh-dashboard,istio-system,app"
  ["kibana"]="http://localhost:[port],util,app"
  ["prometheus"]="http://localhost:[port],istio-system,app"
  ["jaeger"]="http://localhost:[port],istio-system,app,jaeger,16686"
  ["kiali"]="http://localhost:[port],istio-system,app,kiali,20001")
yellow=`tput setaf 3`
red=`tput setaf 9`
reset=`tput sgr0`

initialize() {
  for p in ${configs[paths]}; do
    export PATH=$(brew --prefix ${configs[brew-${p}]:-${p}})/bin:${PATH}
  done; unset p

  # fixme: make minimal-version test more flexible; may not be required when helm:3 is supported more broadly
  # fixme: add conditional `hash helm`
  # if [[ ! "$(helm version --short | grep -i client | cut -d ':' -f 2)" == *"${configs[helm-version]}"* ]]; then
    os=$(os)

    if [[ ! -x ${configs[workdir]}/helm/${os}-amd64/helm ]]; then
      mkdir -p ${configs[workdir]}/helm
      curl -o ${configs[workdir]}/helm/helm-v${helmVersion}.tgz ${configs[helm-distribution]/{os\}/${os}} > /dev/null 2>&1
      (cd ${configs[workdir]}/helm; tar zxvf ${configs[workdir]}/helm/helm-v${helmVersion}.tgz > /dev/null 2>&1)
    fi

    export PATH=${configs[workdir]}/helm/${os}-amd64:${PATH}
    unset os
  # fi

  export NVM_DIR=${HOME}/.nvm
}

warn() {
  echo "${yellow}warn: ${1}${reset}"
}

error() {
  echo "${red}warn: ${1}${reset}"
}

lower() {
  echo "${1}" | tr '[:upper:]' '[:lower:]'
}

prompt() {
  IFS= read -rp "${yellow}${1}${reset}" response
  echo $(lower ${response})
}

beerMe() {
   [ ${#configs[quiet]} -eq 0 ] && echo -ne "\xF0\x9F\x8D\xBA "
}

urlEncode() {
	local LANG=C i c e=''
	for ((i=0;i<${#1};i++)); do
    c=${1:$i:1}
		[[ "${c}" =~ [a-zA-Z0-9\.\~\_\-] ]] || printf -v c '%%%02X' "'${c}"
    e+="${c}"
	done; unset c
  echo "${e}"
}

usage() {
  [ "${1}" ] && warn "${1}"

  cat << EOF
usage: $(basename ${0}) [--options] [commands]

options:
  [-c | --configure] [{key}={value}[,{key}={value}]   : set configuration value(s) by key(s)
                   [{key}+={value}[,{key}+={value}]   : append configuraiton value(s) by key(s)
                   [{key}=                            : clear configuration value(s) by key(s)
  [-p | --preset] [preset-key[,preset-key]]           : preset configuration(s)
  [-w | --workdir] [WORK-DIR]                         : specify working directory
  [-s | --sleep] [PAUSE]                              : specify pause time
  [-q | --quiet]                                      : less verbose
  [-h | --help]                                       : usage

where preset-key in:
  minimal                                             : minimal service deployment; default: preset(local) + mds-agency, postgresql, redis
  local                                               : local resource (cpu, memory) deployment; default: limitsCpu=200m, limitsMemory=200Mi, requestsCpu=20m, requestsMemory=32Mi
  disabled                                            : disable service deployment; default: all
  no-persistence                                      : disable persistence

commands:
  bootstrap                                           : install dependencies; default: ${configs[tools]},${configs[bootstrap]}
  build                                               : build project
  install[:{service[,{service}]}]                     : install specified service; default: ${configs[install]}
  cycle[]:[app[,app]]]                                : restart app; default: cycle all services
  test[:unit,integration]                             : preform specified tests; default: ${configs[test]}
  open:[app[,{app}]]                                  : opens a browser for the provided application(s)
  forward[:{app[,{app}]}]                             : register port-forwarding for the provided application(s); default: ${configs[forward]}
  unforward[:{app[,{app}]}]                           : deregister port-forwarding for the provided application(s)
  cli:[postgresql,redis]                              : create a cli console for the provided service
  uninstall[:{service[,{service}]}]                   : uninstall specified service(s); default: ${configs[uninstall]}
  reinstall[:{service[,{service}]}]                   : reinstall specified service(s); default: ${configs[reinstall]}
  home                                                : return installation directory
  completion                                          : return bash-completion

where service in:
  helm
  kiali
  istio
  mds
  fallbackCertificate                                 : requires ingress domain; eg: -c:ingress-domain=[DOMAIN]
  ingressGatewayCertificate                           : requires certificate path; eg: -c:ingress-gateway-key-path=[KEY-PATH],ingress-gateway-certificate-path=[CERT-PATH]
  metricsAdapter
  logging
  metrics
  nats
  grafana
  dns
  curl

where app in:
  mds-agency
  mds-audit
  mds-compliance
  mds-daily
  mds-geography
  mds-geography-author
  mds-jurisdiction
  mds-jurisdiction-service
  mds-policy
  mds-policy-author
  mds-postgresql
  mds-redis-headless
  grafana                                             : grafana; see: https://grafana.com
  kibana                                              : kibana; see https://www.elastic.co/products/kibana
  prometheus                                          : prometheus; see https://prometheus.io
  jaeger                                              : jaeger; see https://www.jaegertracing.io
  kiali                                               : kiali; see https://www.kiali.io

example:
  % ./bin/$(basename ${0}) bootstrap build install:mds test:integration

pre-requisites:
  docker desktop with kubernetes                      : see https://www.docker.com/products/docker-desktop
EOF

  [ "${1}" ] && exit 1 || exit 0
}

bootstrap() {
  check ${FUNCNAME[0]}

  for r in ${configs[brew]}; do
    rc=${configs[brew-${r}]:-${r}}

    [[ "$(exists ${r})" != "0" ]] && {
      case ${r} in
        oq) brew tap ${rc}; rc=${r};;
        nsc) brew tap ${rc}; rc=${rc}/${r};;
      esac

      brew install ${rc}

      # todo: unable to detect nvm install via subshell given it is an alias
      case ${r} in
        nvm)
          # todo: normalize-nvm env
          [ ! -d ~/.nmv ] && mkdir -p ~/.nvm
          export NVM_DIR=${HOME}/.nvm
          . $(brew --prefix nvm)/nvm.sh
          nvm install ${configs[nvm-version]}
          nvm alias default ${configs[nvm-version]}
          nvm use --delete-prefix v${configs[nvm-version]}
          nvm install node
          nvm use node;;
        envsubst) brew link --force ${lc};;
      esac
    }
  done; unset r rc

  for r in ${configs[brew-cask]}; do
    rc=${configs[brew-cask-${r}]:-${r}}

    [[ "$(exists ${r})" != "0" ]] && {
      brew cask install ${rc}
    }
  done; unset c rc

  initialize

  # todo: normalize nvm-env
  . $(brew --prefix nvm)/nvm.sh
  [ -s "${NVM_DIR}/nvm.sh" ] && . ${NVM_DIR}/nvm.sh
  nvm install ${configs[nvm-version]}
  nvm alias default ${configs[nvm-version]}

  for p in lerna mocha chai mochawesome; do
    yarn ${p} --version > /dev/null 2>&1 || yarn add -W ${p}
  done; unset p

  invoke install "$(normalize ${configs[bootstrap]})"
}

services() {
  echo $(oq -i yaml -r '.apis | keys[]' ${configs[home]}/helm/mds/values.yaml)
}

build() {
  check ${FUNCNAME[0]}

  for s in $(services); do
    for i in $(docker images --filter=reference="${s}" -q); do
      [ ${#i} -ge 1 ] && docker rmi -f ${i}
    done; unset i
  done; unset s

  # todo: provide build-config-option for progressive builds, ie no-clean
  (cd ${configs[home]};
    # todo: normalize nvm-env
    . $(brew --prefix nvm)/nvm.sh;
    [ -s "${NVM_DIR}/nvm.sh" ] && . ${NVM_DIR}/nvm.sh;
    nvm install ${configs[nvm-version]};
    nvm alias default ${configs[nvm-version]};
    [ -z "${configs[keep-cache]}" ] && yarn clean;
    yarn clean;
    yarn;
    yarn image;
    yarn values)

  installImages
}

installImages() {
  check ${FUNCNAME[0]}

  if [ "${configs[image-repository]}" ]; then
    case "${configs[provider],,}" in
      aws) eval $(aws ecr get-login --no-include-email);;
      gcp) ;;
      *) ;;
    esac

    for i in $(docker images --filter "reference=mds-*" --format '{{.Repository}}:{{.Tag}}'); do
      docker tag ${i} ${configs[image-repository]}/${i}
      docker push ${configs[image-repository]}/${i}
    done; unset i
  fi
}

buildImage() {
  docker build -t ${1}$(getBranchSuffix)$(getCommitHash) .
}

getBranchSuffix() {
  git rev-parse --abbrev-ref HEAD | sed -E -e 's/[^-a-zA-Z0-9]/-/g' -e 's/^/-/'
}

getCommitHash() {
  git rev-parse --short HEAD | sed -E -e 's/[^-a-zA-Z0-9]/-/g' -e 's/^/-/'
}

# TODO: DRY
templateDockerCompose() {
  suffix=$(getBranchSuffix)
  for directory in container-images/mds-*; do
    api=$(basename $directory)
    version=$(jq -r '.version' < $directory/package.json)
    varname="$(echo $api | sed -e 's/^mds-//' -e 's/-/_/g' | tr a-z A-Z)_VERSION"
    export $varname=${version}${suffix}
  done
  envsubst < docker-compose.yml.tpl > docker-compose.yml
  echo "Wrote docker-compose.yml"
}

# TODO: DRY
templateValues() {
  branchSuffix=$(getBranchSuffix)
  if [ "$branchSuffix" = "-master" ]; then
    suffix="$branchSuffix"
  else
    suffix="$branchSuffix"$(getCommitHash)
  fi

  for directory in container-images/mds-*; do
    api=$(basename $directory)
    version=$(jq -r '.version' < $directory/package.json)
    varname="$(echo $api | sed -e 's/^mds-//' -e 's/-/_/g' | tr a-z A-Z)_VERSION"
    export $varname=${version}${suffix}
  done
  mkdir -p dist
  envsubst < helm/mds/values.yaml.tpl > dist/values.yaml
  echo "Wrote dist/values.yaml"
}

pause() {
  sleepTime=${1:-${configs[pause]}}
  cntr=0

  echo -ne "waiting "

  while (( cntr < ${sleepTime} )); do
    beerMe
    sleep 3
    cntr=$(($cntr + 3))
  done

  echo ""
}

updateHelmDependencies() {
  for d in $(find ${configs[home]}/helm -mindepth 1 -maxdepth 1 -type d); do
    (cd ${configs[home]}/helm/$(basename ${d}); /bin/rm -rf tmpcharts; helm dependency update)
  done; unset d
}

installHelm() {
  check ${FUNCNAME[0]}

  helm init --force-upgrade || usage "helm intialization failure"
  pause 5

  for r in "${!helmRepositories[@]}"; do
    [[ $(helm repo list | grep ".*${r}.*${helmRepositories[${r}]}.*"  > /dev/null 2>&1; echo $?)  == "1" ]] && {
      helm repo add ${r} ${helmRepositories[${r}]}
    }
  done; unset r

  updateHelmDependencies

  for p in "${!helmPlugins[@]}"; do
    [[ $(helm plugin list | grep ${p}) ]] || helm plugin install ${helmPlugins[${p}]}
  done; unset p

  case "${configs[provider],,}" in
    aws | gcp) installTiller;;
    *);;
  esac
}

helmOptions() {
  for v in ${@}; do
    [ -z ${t+x} ] && t=${v} || opts+="--${t} ${v} "
  done; unset v t

  [ ! -z ${opts+x} ] && echo ${opts}
  unset opts
}

# fixme: cleanup
installTiller() {
  check ${FUNCNAME[0]}

  case "${configs[provider],,}" in
    gcp)
      kubectl create clusterrolebinding cluster-admin-binding \
        --clusterrole=cluster-admin \
        --user="$(gcloud config get-value core/account)"
      kubectl create serviceaccount --namespace kube-system tiller
      kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
      kubectl patch deploy --namespace kube-system tiller-deploy -p '{"spec":{"template":{"spec":{"serviceAccount":"tiller"}}}}';;
    aws) ;&
    *)
      if [ $(kubectl get serviceaccount tiller --namespace kube-system > /dev/null 2>&1; echo $?) == "1" ]; then
        cat << EOF | kubectl create -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: kube-system
EOF
        helm init --service-account tiller --upgrade
      fi;;
  esac
}

installNamespace() {
  check ${FUNCNAME[0]}

  for ns in ${@}; do
    kubectl get namespace ${ns} > /dev/null 2>&1 || kubectl create namespace ${ns} ${configs[dryrun]:+--dry-run}
  done; unset ns
}

installIstio() {
  check ${FUNCNAME[0]}

  if [ ! -d ${configs[istio]} ]; then
    mkdir -p ${configs[workdir]}
    (cd ${configs[workdir]}; curl -L https://git.io/getLatestIstio | ISTIO_VERSION=${configs[istio-version]} sh -)
  fi

# fixme: disable prometheus
  kubectl get namespace istio-system > /dev/null 2>&1 || {
    ${configs[istio]}/bin/istioctl verify-install || error "istio verify installation failure"

    installNamespace istio-system
    pause 2

    case "${configs[provider],,}" in
      gcp)
        helm template ${configs[istio]}/install/kubernetes/helm/istio-init \
          --name istio-init --namespace istio-system \
          ${configs[dryrun]:+--dry-run} | kubectl apply -f -;;
      *)
        helm install ${configs[istio]}/install/kubernetes/helm/istio-init \
          --name istio-init --namespace istio-system \
          ${configs[dryrun]:+--dry-run};;
    esac
    kubectl -n istio-system wait --for=condition=complete job --all

    (( $(kubectl get crds | grep "istio.io" | wc -l) == 23 )) && \
      echo "istio successfully installed" || echo "istio installation failure"

    case "${configs[provider],,}" in
      gcp)
        helm template ${configs[istio]}/install/kubernetes/helm/istio \
          --name istio --namespace istio-system \
          --values ${configs[istio]}/install/kubernetes/helm/istio/values${configs[istio-profile]}.yaml \
          ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
          ${configs[sets-istio]:+$(helmOptions set ${configs[sets-istio]})} \
          ${configs[dryrun]:+--dry-run} | kubectl apply -f -;;
      *)
        helm install ${configs[istio]}/install/kubernetes/helm/istio \
          --name istio --namespace istio-system \
          --values ${configs[istio]}/install/kubernetes/helm/istio/values${configs[istio-profile]}.yaml \
          ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
          ${configs[sets-istio]:+$(helmOptions set ${configs[sets-istio]})} \
          ${configs[dryrun]:+--dry-run};;
    esac

    # labelNamespaceIstioInjection default
    # pause 20
    kubectl --namespace istio-system wait --for=condition=Ready \
      $(kubectl -n istio-system get pod --selector app=istio-ingressgateway --output name --no-headers) \
      --timeout=$((${configs[pause-kubectl]}+30))s || error "istio installation error"
  }
}

labelNamespaceIstioInjection() {
  check ${FUNCNAME[0]}

  kubectl get namespace ${1} > /dev/null 2>&1 && \
    kubectl label namespace ${1} istio-injection=enabled --overwrite=true ${configs[dryrun]:+--dry-run}
}

unlabelNamespacesIstioInjection() {
  check ${FUNCNAME[0]}

  kubectl label namespaces --all istio-injection-
}

installLogging() {
  check ${FUNCNAME[0]}

  kubectl get namespace ${configs[namespace-logging]} > /dev/null 2>&1 || {
    installNamespace ${configs[namespace-logging]}
    # labelNamespaceIstioInjection ${configs[namespace-logging]}
    helm install ${configs[home]}/helm/util --name logging --namespace ${configs[namespace-logging]} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[setfiles]:+$(helmOptions set ${configs[setfiles]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-logging]:+$(helmOptions set ${configs[sets-logging]})} \
      ${configs[dryrun]:+--dry-run}
  }
}

installMetrics() {
  check ${FUNCNAME[0]}

  kubectl get namespace metrics > /dev/null 2>&1 || {
    installNamespace metrics
    helm install ${configs[home]}/helm/metrics --name metrics --namespace metrics \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[setfiles]:+$(helmOptions set ${configs[setfiles]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[dryrun]:+--dry-run}
  }
}

installGrafana() {
  (( $(helm list --short grafana | wc -l) == 0 )) && {
    helm install --name grafana bitnami/grafana --set admin.user=admin --set admin.password=pwd --set plugins=${grafana-plugins}
    # todo: port-forward
  }
}

imageTag() {
  case "${configs[provider],,}" in
    aws) aws ecr describe-images --repository-name ${1} --output text \
      --query 'sort_by(imageDetails,& imagePushedAt)[*].imageTags[*]' | tr '\t' '\n' | tail -1;;
    gcp) gcloud container images list-tags --limit=1 --format='get(TAGS)' ${configs[image-repository]}/${1};;
    *) docker images ${1} --format {{.Tag}};;
  esac
}

imageVersion() {
  for s in $(services); do
    is+="${is:+,}sets-mds+=apis.${s}.version=$(imageTag ${s})"
  done; unset s

  echo ${is}
}

installMds() {
  check ${FUNCNAME[0]}

  # installFallbackCertificate

  (cd ${configs[home]}/helm/mds; /bin/rm -rf tmpcharts; helm dependency update)

  # todo: don't lock on namespace existence
  [[ "$(helm list --short ${configs[namespace-mds]}-mds${configs[helm-upgrade-release]})" = "${configs[namespace-mds]}-mds${configs[helm-upgrade-release]}" ]] || {
    installNamespace ${configs[namespace-mds]}
    labelNamespaceIstioInjection ${configs[namespace-mds]}
    # note: remote registries may require image-version overrides
    [ -z "${configs[image-repository]}" ] && \
      configure $(imageVersion) || configure sets-mds+=registry=${configs[image-repository]}

    pause 5
    # kubectl -n ${configs[namespace-mds]} wait --for=condition=complete job --all

    [[ -d ${configs[operations]}/${configs[helm-cluster]} && "${configs[helm-environment]}" ]] && {
      for f in \
        ${configs[operations]}/${configs[helm-cluster]}/values.yaml \
        ${configs[operations]}/${configs[helm-cluster]}/secrets.yaml \
        ${configs[operations]}/${configs[helm-cluster]}/secrets.${configs[helm-environment]}.yaml \
        ${configs[operations]}/${configs[helm-cluster]}/env.${configs[helm-environment]}.yaml; do
        [[ -f ${f} && -r ${f} ]] && cv+="${cv:+ }${f}"
      done; unset f
    }

    # fixme: impl upgrade, interactive (diff)
    op=install #$([ $(helm list --short | grep ${configs[namespace-mds]}-mds${configs[helm-upgrade-release]}) ] && echo upgrade || echo install)

    helm ${configs[helm-secrets]:+secrets} ${op} ${configs[home]}/helm/mds \
      --name ${configs[namespace-mds]}-mds${configs[helm-upgrade-release]} \
      --namespace ${configs[namespace-mds]} \
      ${cv:+$(helmOptions values ${cv})} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-mds]:+$(helmOptions values ${configs[values-mds]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-mds]:+$(helmOptions set ${configs[presets-mds]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-mds]:+$(helmOptions set ${configs[sets-mds]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-mds]:+$(helmOptions set-file ${configs[setfiles-mds]})} \
      ${configs[dryrun]:+--dry-run --debug}

    unset op cv
    pause 12
    # kubectl -n ${configs[namespace-mds]} wait --for=condition=complete job --all
  }
}

cycle() {
  # check ${FUNCNAME[0]}

  for a in ${@}; do
    (( $(kubectl -n ${configs[namespace-mds]} get pod -l app=${a} --ignore-not-found=true | wc -l) == 2 )) && {
      p=$(kubectl -n ${configs[namespace-mds]} get pod -l app=${a} -o jsonpath='{.items[0].metadata.name}')
      [[ ! -z "${p}" ]] && kubectl -n ${configs[namespace-mds]} delete pod ${p}
    }
  done; unset a p
}

installMetricsAdapter() {
  check ${FUNCNAME[0]}

  helm status kube-metrics-adapter > /dev/null 2>&1 ||
    helm install --name kube-metrics-adapter --namespace ${configs[namespace-metrics-adapter]} \
      banzaicloud-stable/kube-metrics-adapter
}

installFallbackCertificate() {
  if [[ ${configs[ingress-domain]+_} && ${#configs[ingress-domain]} -ge 1 ]]; then
    check ${FUNCNAME[0]}
    TMPCERT=$(mktemp /tmp/k8s-fallback-cert.XXXXXX) || exit 1
    openssl req -x509 -nodes -days 1 -newkey rsa:2048 \
      -keyout ${TMPCERT}.key -out ${TMPCERT}.crt \
      -subj "/CN=${configs[ingress-domain]}/O=${configs[ingress-domain]}"
    kubectl -n istio-system create secret tls gateway-fallback \
      --key ${TMPCERT}.key --cert ${TMPCERT}.crt
    /bin/rm -rf ${TMPCERT} ${TMPCERT}.key ${TMPCERT}.crt
  fi
}

installIngressGatewayCertificate() {
  check ${FUNCNAME[0]}

  if [[ ${configs[ingress-gateway-key-path]+_} && ${#configs[ingress-gateway-key-path]} -ge 1 &&
      ${configs[ingress-gateway-certificate-path]+_} && ${#configs[ingress-gateway-certificate-path]} -ge 1 ]]; then
    check ${FUNCNAME[0]}
    kubectl create -n istio-system secret tls istio-ingressgateway-certs \
      --key ${configs[ingress-gateway-key-path]} \
      --cert ${configs[ingress-gateway-certificate-path]} \
      ${configs[dryrun]:+--dry-run}
  else
    warn "ingress gateway key an certificate is unspecified"
  fi
}

installSimulator() {
  check ${FUNCNAME[0]}

  if [[ ! -d ${configs[simulator]} ]]; then
    mkdir -p ${configs[workdir]}
    (cd ${configs[workdir]};
      git clone ${configs[simulator-repository]} ${configs[simulator]} || \
        usage "invalid repository: ${configs[simulator-repository]}";
      cd ${configs[simulator]};
      git pull)
  fi

  [[ "$(helm list --short ${configs[namespace-simulator]}-trackgen)" = "${configs[namespace-simulator]}-trackgen" ]] || {
    for i in $(docker images --filter=reference="trackgen" -q); do
      docker rmi -f ${i}
    done; unset i
    (cd ${configs[simulator]};
      export version=0.0.1$(getBranchSuffix)$(getCommitHash);
      docker build -t trackgen:${version} .;
      [[ "${configs[image-repository]}" ]] && {
        docker tag trackgen:${version} ${configs[image-repository]}/trackgen:${version};
        docker push ${configs[image-repository]}/trackgen:${version};
      }
      helm install ${configs[simulator]}/helm --name ${configs[namespace-simulator]}-trackgen \
        ${configs[namespace-simulator]:+--namespace ${configs[namespace-simulator]}} \
        --set version=${version} \
        ${configs[values]:+$(helmOptions values ${configs[values]})} \
        ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
        ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
        ${configs[sets-simulator]:+$(helmOptions set ${configs[sets-simulator]})} \
        ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
        ${configs[dryrun]:+--dry-run --debug})
  }
}

installOperations() {
  check ${FUNCNAME[0]}

  if [[ ! -d ${configs[operations]} ]]; then
    mkdir -p ${configs[workdir]}
    (cd ${configs[workdir]};
      git clone ${configs[operations-repository]} ${configs[operations]} || \
        usage "invalid repository: ${configs[operations-repository]}";
      cd ${configs[operations]};
      git pull)
  fi
}

installCredentials() {
  check ${FUNCNAME[0]}

  [[ ! -d ${configs[credentials]} && -n "${configs[credentials-repository]}" ]] && {
    mkdir -p ${configs[workdir]}
    (cd ${configs[workdir]};
      git clone ${configs[credentials-repository]} ${configs[credentials]} || \
        usage "invalid repository: ${configs[credentials-repository]}";
      cd ${configs[credentials]};
      git pull)
  } || return 0
}

nkeysPath() {
  echo $([[ -d ${configs[credentials]}/nats/nsc/nkeys ]] && \
    echo ${configs[credentials]}/nats/nsc/nkeys || echo ${HOME}/.nkeys)
}

nscHome() {
  echo $([[ -d ${configs[credentials]}/nats/nsc/nsc/nats ]] && \
    echo ${configs[credentials]}/nats/nsc/nsc/nats || echo ${HOME}/.nsc/nats)
}

installNsc() {
  check ${FUNCNAME[0]}

  (export NKEYS_PATH=$(nkeysPath)
    export NSC_HOME=$(nscHome)
    cd ${NSC_HOME}
    nsc init --name KO > /dev/null 2>&1 || echo "trusted operator already exists"
    nsc describe operator --name KO > /dev/null 2>&1 || nsc add operator --name KO
    nsc describe account --name SYS > /dev/null 2>&1 || nsc add account --name SYS
    nsc describe user --account SYS --name sys > /dev/null 2>&1 || nsc add user --account SYS --name sys)

  [[ ! -f ${configs[nats]}/resolver.conf ]] &&
    (export NKEYS_PATH=$(nkeysPath)
      export NSC_HOME=$(nscHome)
      cd ${NSC_HOME}
      mkdir -p ${configs[nats]}
      nsc generate config --mem-resolver --sys-account sys > ${configs[nats]}/resolver.conf)
}

installNas() {
  check ${FUNCNAME[0]}

  releaseName="${configs[nats-namespace-account-server]}-nats-account-server}"
  releases="$(helm list --quiet)"

  if ! echo $releases | grep -E -q "(^| )$releaseName($| )"; then # this release has not yet been installed
    nscOperatorData=${configs[nats]}/nats-operator-data.zip

    [[ ! -f ${nscOperatorData} ]] && (cd $(nscHome); zip -r ${nscOperatorData} .)
    # [[ ! -f helm/nats-account-server/nats-operator-data.zip ]] && ln -s ${nscOperatorData} helm/nats-account-server/nats-operator-data.zip

    helm install ${configs[home]}/helm/nats-account-server --name ${configs[namespace-nats-account-server]}-nats-account-server \
      ${configs[namespace-nats-account-server]:+--namespace ${configs[namespace-nats-account-server]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      # $(helmOptions set nscOperatorData=nats-operator-data.zip) \
      ${configs[dryrun]:+--dry-run --debug}
    # fixme: push to helm chart
    kubectl --namespace ${configs[namespace-nats-account-server]} create configmap nats-operator-data --from-file ${nscOperatorData}

    kubectl --namespace ${configs[namespace-nats-account-server]} wait --for=condition=Ready pod --selector=app=nats-account-server \
        --timeout=${configs[pause-kubectl]}s || error "nas installation error"
    pause 3
  fi
}

installNatsInit() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-init)" = "${configs[namespace-nats]}-nats-init" ]] || {
    helm install ${configs[home]}/helm/nats-init --name ${configs[namespace-nats]}-nats-init \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}}
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug} # > /dev/null 2>&1
    # fixme: do better; wait for crd(natsclusters.nats.io, natsservicerles.nats.io)
    pause 3
  }
}

installNats() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-server)" = "${configs[namespace-nats]}-nats-server" ]] || {
    systemAccount=$(nsc describe account --name SYS | grep "Account ID" | awk '{print $5}')
    operatorJwt=$(< $(nscHome)/KO/KO.jwt)

    helm install ${configs[home]}/helm/nats-server --name ${configs[namespace-nats]}-nats-server \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      $(helmOptions set systemAccount=${systemAccount}) \
      $(helmOptions set operatorJwt=${operatorJwt}) \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}

    pause 1
    # fixme: check on nats pod status
    kubectl --namespace ${configs[namespace-nats]} wait --for=condition=Ready pods \
      --selector=app=${configs[namespace-nats]}-nats-server --timeout=${configs[pause-kubectl]}s || \
      error "nats-server installation error"
  }
}

installNatsbox() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-nats-box]}-nats-box)" = "${configs[namespace-nats-box]}-nats-box" ]] || \
    helm install ${configs[home]}/helm/nats-box --name ${configs[namespace-nats-box]}-nats-box \
      ${configs[namespace-nats-box]:+--namespace ${configs[namespace-nats-box]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}
}

installSurveyor() {
  [[ "$(helm list --short ${configs[namespace-nats]}-prometheus-operator)" = "${configs[namespace-nats]}-prometheus-operator" ]] || {
    helm install ${configs[home]}/helm/prometheus-operator --name ${configs[namespace-nats]}-prometheus-operator \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}

    kubectl --namespace ${configs[namespace-nats]} wait --for=condition=Available deployment.apps/prometheus-operator \
      --timeout=${configs[pause-kubectl]}s || error "prometheus-operator installation error"
  }

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-prometheus)" = "${configs[namespace-nats]}-nats-prometheus" ]] || {
    helm install ${configs[home]}/helm/nats-prometheus --name ${configs[namespace-nats]}-nats-prometheus \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}

    # todo: fix block
    # kubectl --namespace ${configs[namespace-nats]} wait --for=condition=Available deployment.apps/nats-surveyor-grafana \
    #   --timeout=${configs[pause-kubectl]}s || error "nats-prometheus installation error"
  }

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-surveyor-grafana)" = "${configs[namespace-nats]}-nats-surveyor-grafana" ]] || {
    helm install ${configs[home]}/helm/nats-surveyor-grafana --name ${configs[namespace-nats]}-nats-surveyor-grafana \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}

    # todo: fix block
    # kubectl --namespace ${configs[namespace-nats]} wait --for=condition=Ready pod --selector=app=nats-surveyor-grafana \
      # --timeout=${configs[pause-kubectl]}s || error "nats-surveyor-grafana installation error"
  }

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-surveyor)" = "${configs[namespace-nats]}-nats-surveyor" ]] || {
    helm install ${configs[home]}/helm/nats-surveyor --name ${configs[namespace-nats]}-nats-surveyor \
      ${configs[namespace-nats]:+--namespace ${configs[namespace-nats]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[values-nats]:+$(helmOptions values ${configs[values-nats]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[presets-nats]:+$(helmOptions set ${configs[presets-nats]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[sets-nats]:+$(helmOptions set ${configs[sets-nats]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[setfiles-nats]:+$(helmOptions set-file ${configs[setfiles-nats]})} \
      ${configs[dryrun]:+--dry-run --debug}

    # kubectl --namespace ${configs[namespace-nats]} wait --for=condition=Ready pod --selector=app=nats-surveyor \
    #   --timeout=${configs[pause-kubectl]}s || error "nats-surveyor installation error"
  }
}

installDns() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-dns]}-dns)" = "${configs[namespace-dns]}-dns" ]] || \
    helm install ./helm/dns --name ${configs[namespace-dns]}-dns \
      ${configs[namespace-dns]:+--namespace ${configs[namespace-dns]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[dryrun]:+--dry-run --debug}
}

installCurl() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-curl]}-curl)" = "${configs[namespace-curl]}-curl" ]] || \
    helm install ./helm/curl --name ${configs[namespace-curl]}-curl \
      ${configs[namespace-curl]:+--namespace ${configs[namespace-curl]}} \
      ${configs[values]:+$(helmOptions values ${configs[values]})} \
      ${configs[presets]:+$(helmOptions set ${configs[presets]})} \
      ${configs[sets]:+$(helmOptions set ${configs[sets]})} \
      ${configs[setfiles]:+$(helmOptions set-file ${configs[setfiles]})} \
      ${configs[dryrun]:+--dry-run --debug}
}

testUnit() {
  check ${FUNCNAME[0]}

# todo: enable when tests don't block
#  yarn test

  helm unittest ${configs[home]}/helm/mds
}

testIntegration() {
  check ${FUNCNAME[0]}

  # todo: provide [ ui | cli ] option
  # yarn cypress open
  # yarn cypress run
}

get() {
  v=$(echo ${1} | cut -sd ',' -f ${2})
  [ ! -z "${v}" ] && echo ${v} || echo ${3}
  unset v
}

portForward() {
  check ${FUNCNAME[0]}

  fa=${apps[${1}]}
  fns=$(get ${fa} 2)
  fk=$(get ${fa} 3)
  fv=$(get ${fa} 4 ${1})
  fp=$(get ${fa} 5 -1)

  (( $(kubectl -n ${fns} get pod -l ${fk}=${fv} --ignore-not-found=true | wc -l) == 2 )) && {
    fa=$(kubectl -n ${fns} get pod -l ${fk}=${fv} -o jsonpath='{.items[0].metadata.name}')

    [ ${fp} -eq "-1" ] && \
      fp=$(kubectl -n ${fns} get pod -l ${fk}=${fv} -o jsonpath='{.items[0].spec.containers[0].ports[0].containerPort}')

    kubectl -n ${fns} port-forward ${fa} ${fp}:${fp} > /dev/null 2>&1 &
    pause 3
  }

  unset fa fns fk fv fa fp
}

forward() {
  for fa in ${@}; do
    [ ${apps[${fa}]+_} ] && portForward ${fa} || warn "unknown app: ${fa}"
  done; unset fa
}

unforward() {
  [ ! -z "${@}" ] || ps -ef | grep -E 'kubectl.*port-forward' | grep -v grep | awk '{print $2}' | xargs kill -9

  for ua in ${@}; do
    if [ ${apps[${ua}]+_} ]; then
      ps -ef | grep -E 'kubectl.*port-forward' | grep ${ua} | grep -v grep | awk '{print $2}' | xargs kill -9
    else
      warn "unknown app: ${ua}"
    fi
  done; unset ua
}

getApp() {
  check ${FUNCNAME[0]}

  ga=${apps[${1}]}
  gu=$(get ${ga} 1)
  gns=$(get ${ga} 2)
  gk=$(get ${ga} 3)
  gv=$(get ${ga} 4 ${1})
  gp=$(get ${ga} 5 -1)

  [ ${gp} -eq -1 ] && {
    (( $(kubectl -n ${gns} get pod -l ${gk}=${gv} --ignore-not-found=true | wc -l) == 2 )) &&
      gp=$(kubectl -n ${gns} get pod -l ${gk}=${gv} \
        -o jsonpath='{.items[0].spec.containers[0].ports[0].containerPort}')
  }

  echo ${gu/\[port\]/${gp}}
  unset ga gu gns gks gv gp
}

app() {
  for a in ${1}; do
    if [ ${apps[${a}]+_} ]; then
      check ${FUNCNAME[0]}:${a}

      case "${configs[os]}" in
        ${os[osx]}) open $(getApp ${a});;
        *) usage "unsupported os: ${configs[os]}";;
      esac
    else
      invoke app ${a}
    fi
  done; unset a
}

cliPostgresql() {
  check ${FUNCNAME[0]}
  # pgcli postgres://mdsadmin@localhost:5432/mds
  kubectl -n ${configs[namespace-mds]} run -it --image=dencold/pgcli --rm=true --attach pgcli \
    postgres://mdsadmin:$(urlEncode ${configs[presets-mds-database-password]})@${configs[namespace-mds]}-postgresql:5432/mds
}

cliRedis() {
  check ${FUNCNAME[0]}
  # redis-cli -u redis://localhost:6379/0
  echo "issue command: redis-cli -u redis://${configs[namespace-mds]}-redis-master:6379/0"
  kubectl -n ${configs[namespace-mds]} run -it --image=redis --rm=true --attach redis-cli \
    /bin/bash #redis-cli -u redis://${configs[namespace-mds]}-redis-master:6379/0
}

uninstallNamespace() {
  check ${FUNCNAME[0]}

  for ns in ${@}; do
    kubectl get namespace ${1} > /dev/null 2>&1 && kubectl delete namespace ${ns} \
      ${configs[dryrun]:+--dry-run}
  done; unset ns
}

uninstallHelm() {
  case "${configs[provider],,}" in
    aws | gcp) uninstallTiller;;
    *);;
  esac
}

uninstallSimulator() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-simulator]}-trackgen)" = "${configs[namespace-simulator]}-trackgen" ]] && {
    helm del --purge ${configs[namespace-simulator]}-trackgen

    if [ -z "${configs[keep-cache]}" ]; then
      [ -d ${configs[simulator]} ] && /bin/rm -rf ${configs[simulator]}
    fi
  }
}

uninstallOperations() {
  check ${FUNCNAME[0]}

  if [ -z "${configs[keep-cache]}" ]; then
    [ -d ${configs[operations]} ] && /bin/rm -rf ${configs[operations]}
  fi
}

uninstallCredentials() {
  check ${FUNCNAME[0]}

  # todo: not sure we want to rm local creds repo just yet
  # if [ -z "${configs[keep-cache]}" ]; then
  #   [ -d ${configs[credentials]} ] && /bin/rm -rf ${configs[credentials]}
  # fi
}

uninstallFallbackCertificate() {
  check ${FUNCNAME[0]}

  kubectl get secret gateway-fallback > /dev/null 2>&1 &&
    kubectl delete secret gateway-fallback
}

uninstallIngressGatewayCertificate() {
  check ${FUNCNAME[0]}

  kubectl get secret istio-ingressgateway-certs > /dev/null 2>&1 &&
    kubectl delete secret istio-ingressgateway-certs
}

uninstallMetricsAdapter() {
  check ${FUNCNAME[0]}

  helm status kube-metrics-adapter > /dev/null 2>&1 && helm delete --purge kube-metrics-adapter
}

uninstallGrafana() {
  (( $(helm list --short grafana | wc -l) == 1 )) && {
    # todo: unforward
    helm delete --purge grafana
  }
}

uninstallMds() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-mds]}-mds${configs[helm-upgrade-release]})" = "${configs[namespace-mds]}-mds${configs[helm-upgrade-release]}" ]] && {
    helm delete --purge ${configs[namespace-mds]}-mds${configs[helm-upgrade-release]} ${configs[dryrun]:+--dry-run}
    uninstallNamespace ${configs[namespace-mds]}
  }
}

uninstallSurveyor() {
  for n in prometheus-operator nats-prometheus nats-surveyor-grafana nats-surveyor; do
    [[ "$(helm list --short ${configs[namespace-nats]}-${n})" = "${configs[namespace-nats]}-${n}" ]] && \
      helm delete --purge ${configs[namespace-nats]}-${n}
  done; unset n
}

uninstallNatsbox() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-nats-box]}-nats-box)" = "${configs[namespace-nats-box]}-nats-box" ]] && \
    helm delete --purge ${configs[namespace-nats-box]}-nats-box
}

uninstallNas() {
  check ${FUNCNAME[0]}

  [[ "$(helm list --short ${configs[namespace-nats-account-server]}-nats-account-server)" = "${configs[namespace-nats-account-server]}-nats-account-server" ]] && \
    helm delete --purge ${configs[namespace-nats-account-server]}-nats-account-server

  kubectl --namespace ${configs[namespace-nats-account-server]} delete configmap nats-operator-data
}

uninstallNatsInit() {
  check ${FUNCNAME[0]}

  uninstallNas

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-init)" = "${configs[namespace-nats]}-nats-init" ]] && \
      helm delete --purge ${configs[namespace-nats]}-nats-init

  for c in crd/natsclusters.nats.io crd/natsserviceroles.nats.io; do
    kubectl delete ${c}
  done; unset c
}

uninstallNats() {
  check ${FUNCNAME[0]}

  # (creds) uninstallNas

  [[ "$(helm list --short ${configs[namespace-nats]}-nats-server)" = "${configs[namespace-nats]}-nats-server" ]] && \
      helm delete --purge ${configs[namespace-nats]}-nats-server

  kubectl delete namespace ${configs[namespace-nats]}
  # for n in enpoints/nats-server secret/default-token-* secret/istio.default serviceaccount/default do
  #   kubectl -n ${configs[namespace-nats]} delete ${n}
  # done; unset n
}

uninstallNsc() {
  # todo: rm ~/{.nkeys,nsc}
  if [ -z "${configs[keep-cache]}" ]; then
    [[ -d ${configs[nats]} ]] && /bin/rm -rf ${configs[nats]}
  fi
}

uninstallDns() {
  [[ "$(helm list --short ${configs[namespace-dns]}-dns)" = "${configs[namespace-dns]}-dns" ]] && \
    helm delete --purge ${configs[namespace-dns]}-dns
}

uninstallCurl() {
  [[ "$(helm list --short ${configs[namespace-curl]}-curl)" = "${configs[namespace-curl]}-curl" ]] && \
    helm delete --purge ${configs[namespace-curl]}-curl
}

uninstallMetrics() {
  check ${FUNCNAME[0]}

  helm delete --purge metrics ${configs[dryrun]:+--dry-run}
  uninstallNamespace metrics
}

uninstallLogging() {
  check ${FUNCNAME[0]}

  helm delete --purge logging ${configs[dryrun]:+--dry-run}
  # todo: ns/util may host more apps then logging
  #uninstallNamespace ${configs[namespace-logging]}
}

uninstallKiali() {
  check ${FUNCNAME[0]}

  unforward kiali
  helm delete --purge kiali
  uninstallNamespace kiali
  # kubectl delete secrets kubernetes-dashboard-key-holder -n kube-system ${configs[dryrun]:+--dry-run}
  kubectl get namespace kiali > /dev/null 2>&1 && kubectl delete namespace kiali \
    ${configs[dryrun]:+--dry-run}
}

uninstallIstio() {
  check ${FUNCNAME[0]}

  kubectl get namespace istio-system > /dev/null 2>&1 && {
    check ${FUNCNAME[0]}
    case "${config[provider]}" in
      gcp)
        helm template install/kubernetes/helm/istio --name istio --namespace istio-system | kubectl delete -f -;;
      *)
        helm delete --purge istio ${configs[dryrun]:+--dry-run}
        helm delete --purge istio-init ${configs[dryrun]:+--dry-run}
        kubectl delete namespace istio-system ${configs[dryrun]:+--dry-run}
        kubectl delete -f ${configs[istio]}/install/kubernetes/helm/istio-init/files \
          ${configs[dryrun]:+--dry-run} > /dev/null;;
    esac
    kubectl delete namespace istio-system
    unlabelNamespacesIstioInjection
  }

  if [ -z "${configs[keep-cache]}" ]; then
    [[ -d ${configs[istio]} && -z "${configs[dryrun]}" ]] && /bin/rm -rf ${configs[istio]}
  fi
}

uninstallTiller() {
  check ${FUNCNAME[0]}

  if [ $(kubectl get serviceaccount tiller --namespace kube-system > /dev/null 2>&1; echo $?) == "0" ]; then
    kubectl delete serviceaccount tiller --namespace kube-system
    kubectl delete clusterrolebinding tiller-clusterrolebinding
    helm reset --force
    pause 3
    helm init --upgrade
  fi
  case "${configs[provider],,}" in
    gcp)
      if [ $(kubectl get serviceaccount tiller --namespace kube-system > /dev/null 2>&1; echo $?) == "0" ]; then
        kubectl delete serviceaccount tiller --namespace kube-system
        kubectl delete clusterrolebinding tiller-clusterrolebinding
        helm reset --force
        pause 3
        helm init --upgrade
      fi;;
    aws) ;&
    *)
      if [ $(kubectl get serviceaccount tiller --namespace kube-system > /dev/null 2>&1; echo $?) == "1" ]; then
        cat << EOF | kubectl delete -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: kube-system
EOF
        helm reset --force
        pause 3
        helm init --upgrade
      fi;;
  esac
}

getPort() {
  if [ ${apps[${1}]+_} ]; then
    check ${FUNCNAME[0]}
    ga=${apps[${1}]}
    gns=$(get ${ga} 2)
    gk=$(get ${ga} 3)
    gv=$(get ${ga} 4 ${1})
    gp=$(get ${ga} 5 -1)

    [ ${gp} -eq -1 ] && {
      (( $(kubectl -n ${gns} get pod -l ${gk}=${gv} --ignore-not-found=true | wc -l) == 2 )) &&
        gp=$(kubectl -n ${gns} get pod -l ${gk}=${gv} \
          -o jsonpath='{.items[0].spec.containers[0].ports[0].containerPort}')
    }
  fi; unset ga gns gk gv

  echo ${gp:-}
}

forwardIfNeeded() {
  gp=$(getPort ${1})

  if [ ${gp} -eq "-1" ]; then
    [[ "$(exists install${1^})" == "0" ]] && invoke install ${1}
    pause 3
    gp=$(getPort ${1})
  fi

  if [ ${#gp} -ge 1 ]; then
    echo 'exit' | telnet localhost ${gp} > /dev/null 2>&1 || forward ${1}
  fi

  unset gp
}

localContext() {
  [[ "$(lower $(kubectl config current-context))" =~ ^(${configs[local-context]})$ ]] && echo true || echo false
}

context() {
  [ -z ${context+x} ] && [ "$(localContext)" != "true" ] && {
    v=yes
    [[ "$(prompt "confirm you want to proceed: [${v}/no] ")" != "${v}" ]] && usage "opted to exit" || context=true
    unset v
  }
}

check() {
  nc=("$(basename ${0})" bootstrap build installHelm)
  [[ ! " ${nc[@]} " =~ " ${1} " ]] && context

  case "${1}" in
    $(basename ${0}))
      for rc in ${configs[rc]}; do
        if [[ -f ${rc} && $(grep -q "\\\*${configs[home]}/bin\\\*" ${rc}; echo $?) != 0 ]]; then
          echo "export PATH=${configs[home]}/bin:\${PATH}" >> ${rc}
        fi
      done; unset rc

      for d in docker kubectl; do
        [[ "$(exists ${d})" != "0" ]] && usage "install: ${d}"
      done; unset d
      # todo: include cluster connection check where needed if not globally
      kubectl cluster-info > /dev/null 2>&1 || usage "connect to kubernetes cluster";;
    build | testIntegration)
      [[ "$(exists yarn)" != "0" ]] && bootstrap;;
    installCredentials) ;;
    installNsc) installCredentials;;
    installNas) installNsc;;
    installNatsInit) ;;
    installNats) ;; # (creds) installNas; installNatsInit;;
    # installImages)
    #   [ "${configs[image-repository]}" ] || \
    #     warn "configure an image-repository; eg ' ... -c:image-repository=[image-repository-url] ...'";;
    # installNas) installNats;;
    installMds)
      [[ "$(exists helm)" != "0" ]] && bootstrap
      kubectl get namespace istio-system > /dev/null 2>&1 || installIstio
      # fixme: test ${configs[helm-environment]}
      # (creds) installNsc;;
      [ "${configs[helm-environment]}" ] && installOperations
      # fixme: better operations pre-check
      #[ ! -d ${configs[operations]}/${configs[helm-cluster]} ] && usage "unspecified cluster"
      ;;
    installMetrics) kubectl get namespace istio-system > /dev/null 2>&1 || installIstio;&
    installHelm | installIstio | installLogging | installMetricsAdapter | testUnit | \
      uninstallMds | uninstallMetrics | uninstallLogging | uninstallIstio)
      [[ "$(exists helm)" != "0" ]] && bootstrap;;
    uninstallNats) ;; # (creds) uninstallNas;;
    installSimulator)
      [[ ! -d ${configs[simulator]} && ! "${configs[simulator-repository]}" ]] && usage "unspecified simulator repository";;
    app:*) forwardIfNeeded ${1##*:};;
    cliPostgresql) ;;
    cliRedis) ;;
  esac
}

invoke() {
  for ia in ${2}; do
    ${1}${ia^} || warn "${1} error: ${ia}"
  done; unset ia
}

invokeAny() {
  for ia in ${1}; do
    ${ia} || warn "${ia} error: ${ia}"
  done; unset ia
}

normalize() {
  echo ${1} | cut -d ${2:-:} -f 2- | tr ',' ' '
}

configure() {
  if [[ ${1} == *"="* ]]; then
    for c in $(echo ${1} | tr ',' ' '); do
      k=$(echo ${c} | cut -d '=' -f 1)
      v=$(echo ${c} | cut -d '=' -f 2-)
      [[ "${k}" == *"+" ]] && configs[${k%+}]+="${configs[${k%+}]:+,}${v}" || configs[${k}]="${v}"
    done; unset c k v
  elif [[ ! -z "${1}" ]]; then
    configs[${1}]=
  fi
}

preset() {
  for p in ${@}; do
    case ${p} in
      disable)
        for s in $(services); do
          is+="${is:+,}presets-mds+=apis.${s}.enabled=false"
        done; unset s;;
      local)
        is+="${is:+,}presets+=resourcesLimitsCpu=200m"
        is+="${is:+,}presets+=resourcesLimitsMemory=200Mi"
        is+="${is:+,}presets+=resourcesRequestsCpu=20m"
        is+="${is:+,}presets+=resourcesRequestsMemory=32Mi"
        is+="${is:+,}presets-nats+=cluster.size=1"
        is+="${is:+,}presets-nats+=maximumAge=4h"
        is+="${is:+,}presets-nats+=maximumBytes=1GB"
        is+="${is:+,}presets-nats+=cluster.size=1"
        is+="${is:+,}presets-nats+=clusterSize=1";;
      no-persistence)
        is+="${is:+,}sets-mds+=postgresql.persistence.enabled=false"
        is+="${is:+,}sets-mds+=postgresql.volumePermissions.enabled=true"
        is+="${is:+,}sets-mds+=postgresql.securityContext.enabled=false"
        is+="${is:+,}sets-mds+=redis.persistence.enabled=false"
        is+="${is:+,}sets-mds+=redis.master.persistence.enabled=false"
        is+="${is:+,}sets-mds+=redis.slave.persistence.enabled=false";;
      minimal)
        preset $(normalize "disable,local,no-persistence")
        is+="${is:+,}sets-mds+=apis.mds-agency.enabled=true";;
      data-external)
        is+="${is:+,}sets-mds+=postgresql.internal=false"
        is+="${is:+,}sets-mds+=postgresql.host=host.docker.internal"
        is+="${is:+,}sets-mds+=postgresql.hostReader=host.docker.internal"
        is+="${is:+,}sets-mds+=redis.internal=false"
        is+="${is:+,}sets-mds+=redis.host=host.docker.internal";;
      helm-secrets)
        is+="${is:+,}helm-secrets=true";;
    esac
  done; unset p

  [ ${#is} -ge 1 ] && configure ${is}
  unset is
}

[[ -z ${configs[profiles]} ]] & preset "$(normalize ${configs[profiles]})"
initialize
check $(basename ${0})

while getopts ":w:s:c:p:q-:h-:" opt; do
  case "${opt}" in
    -)
      case "${OPTARG}" in
        configure) configure "$(echo ${!OPTIND})"; OPTIND=$(( ${OPTIND} + 1 ));;
        configure=*) configure "$(echo ${OPTARG#*=})";;
        preset) preset "$(normalize ${!OPTIND})"; OPTIND=$(( ${OPTIND} + 1 ));;
        preset=*) preset "$(normalize ${OPTARG#*=})";;
        workdir) configs[workdir]="${!OPTIND}"; OPTIND=$(( ${OPTIND} + 1 ));;
        workdir=*) configs[workdir]="${OPTARG#*=}";;
        sleep) configs[pause]="${!OPTIND}"; OPTIND=$(( ${OPTIND} + 1 ));;
        sleep=*) configs[pause]="${OPTARG#*=}";;
        quiet) confgs[quiet]=true;;
        help) usage;;
        *) [ "${OPTERR}" = 1 ] && [ "${optspec:0:1}" != ":" ] && error "unknown option --${OPTARG}";;
      esac;;
    c) configure "$(echo ${OPTARG})";;
    p) preset "$(normalize ${OPTARG})";;
    w) configs[workdir]=${OPTARG};;
    s) configs[pause]=${OPTARG};;
    q) configs[quiet]=true;;
    h) usage;;
    :) usage "option -${OPTARG} requires an argument" 1;;
    \?) [ "${OPTERR}" != 1 ] || [ "${optspec:0:1}" = ":" ] && error "unknown option -${OPTARG}" 1;;
  esac
done

[[ ${#} == 0 ]] && usage
[[ ! -d ${configs[workdir]} ]] && mkdir -p ${configs[workdir]}

for arg in "${@:$OPTIND}"; do
  case "${arg}" in
    bootstrap) bootstrap || warn  "${arg} failure";;
    build) build || usage "${arg} failure";;
    buildImage) buildImage ${configs[image-name]};;
    templateValues) templateValues;;
    templateDockerCompose) templateDockerCompose;;
    install:namespace=*) installNamespace "$(normalize ${arg} =)";;
    install) arg="${configs[install]}";&
    install:*) invoke install "$(normalize ${arg})";;
    cycle) s=$(services); arg="${s// /,},${p// /,}"; unset s p;&
    cycle:*) cycle "$(normalize ${arg})";;
    test) arg="${configs[test]}";&
    test:*) invoke test "$(normalize ${arg})";;
    forward) arg="${configs[forward]}";&
    forward:*) forward "$(normalize ${arg})";;
    unforward) unforward;;
    unforward:*) unforward "$(normalize ${arg})";;
    open) usage "specify an application(s) to open";;
    open:*) app "$(normalize ${arg})";;
    cli:*) invoke cli "$(normalize ${arg})";;
    uninstall:namespace=*) uninstallNamespace "$(normalize ${arg} =)";;
    uninstall) arg="${configs[uninstall]}";&
    uninstall:*) invoke uninstall "$(normalize ${arg})";;
    reinstall) arg="${configs[reinstall]}";&
    reinstall:*)
    invoke uninstall "$(normalize ${arg})"
    invoke install "$(normalize ${arg})";;
    home) echo ${configs[home]};;
    completion) cat ${configs[home]}/bin/mdsctl-completion.bash;;
    *) invokeAny "$(normalize ${arg})";; #error "unknown command: ${arg}"
  esac
done; unset arg
